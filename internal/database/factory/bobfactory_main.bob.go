// Code generated by BobGen psql v0.41.1. DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package factory

import (
	"context"
	"time"

	"github.com/aarondl/opt/null"
	"github.com/gofrs/uuid/v5"
	enums "github.com/jacoobjake/einvoice-api/internal/database/enums"
	models "github.com/jacoobjake/einvoice-api/internal/database/models"
	"github.com/stephenafamo/bob/types/pgtypes"
)

type Factory struct {
	baseAuthTokenMods   AuthTokenModSlice
	baseFailedLoginMods FailedLoginModSlice
	baseUserMods        UserModSlice
}

func New() *Factory {
	return &Factory{}
}

func (f *Factory) NewAuthToken(mods ...AuthTokenMod) *AuthTokenTemplate {
	return f.NewAuthTokenWithContext(context.Background(), mods...)
}

func (f *Factory) NewAuthTokenWithContext(ctx context.Context, mods ...AuthTokenMod) *AuthTokenTemplate {
	o := &AuthTokenTemplate{f: f}

	if f != nil {
		f.baseAuthTokenMods.Apply(ctx, o)
	}

	AuthTokenModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingAuthToken(m *models.AuthToken) *AuthTokenTemplate {
	o := &AuthTokenTemplate{f: f, alreadyPersisted: true}

	o.ID = func() int64 { return m.ID }
	o.UserID = func() int64 { return m.UserID }
	o.Type = func() enums.AuthTokenTypes { return m.Type }
	o.Token = func() string { return m.Token }
	o.ExpireAt = func() null.Val[time.Time] { return m.ExpireAt }
	o.CreatedAt = func() null.Val[time.Time] { return m.CreatedAt }
	o.UpdatedAt = func() null.Val[time.Time] { return m.UpdatedAt }
	o.SessionID = func() null.Val[uuid.UUID] { return m.SessionID }

	ctx := context.Background()
	if m.R.User != nil {
		AuthTokenMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewFailedLogin(mods ...FailedLoginMod) *FailedLoginTemplate {
	return f.NewFailedLoginWithContext(context.Background(), mods...)
}

func (f *Factory) NewFailedLoginWithContext(ctx context.Context, mods ...FailedLoginMod) *FailedLoginTemplate {
	o := &FailedLoginTemplate{f: f}

	if f != nil {
		f.baseFailedLoginMods.Apply(ctx, o)
	}

	FailedLoginModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingFailedLogin(m *models.FailedLogin) *FailedLoginTemplate {
	o := &FailedLoginTemplate{f: f, alreadyPersisted: true}

	o.ID = func() int64 { return m.ID }
	o.UserID = func() int64 { return m.UserID }
	o.IPAddress = func() pgtypes.Inet { return m.IPAddress }
	o.AttemptedAt = func() null.Val[time.Time] { return m.AttemptedAt }

	ctx := context.Background()
	if m.R.User != nil {
		FailedLoginMods.WithExistingUser(m.R.User).Apply(ctx, o)
	}

	return o
}

func (f *Factory) NewUser(mods ...UserMod) *UserTemplate {
	return f.NewUserWithContext(context.Background(), mods...)
}

func (f *Factory) NewUserWithContext(ctx context.Context, mods ...UserMod) *UserTemplate {
	o := &UserTemplate{f: f}

	if f != nil {
		f.baseUserMods.Apply(ctx, o)
	}

	UserModSlice(mods).Apply(ctx, o)

	return o
}

func (f *Factory) FromExistingUser(m *models.User) *UserTemplate {
	o := &UserTemplate{f: f, alreadyPersisted: true}

	o.ID = func() int64 { return m.ID }
	o.FirstName = func() string { return m.FirstName }
	o.LastName = func() string { return m.LastName }
	o.Password = func() string { return m.Password }
	o.Email = func() string { return m.Email }
	o.EmailVerifiedAt = func() null.Val[time.Time] { return m.EmailVerifiedAt }
	o.Status = func() enums.UserStatuses { return m.Status }
	o.CreatedAt = func() null.Val[time.Time] { return m.CreatedAt }
	o.UpdatedAt = func() null.Val[time.Time] { return m.UpdatedAt }
	o.DeletedAt = func() null.Val[time.Time] { return m.DeletedAt }

	ctx := context.Background()
	if len(m.R.AuthTokens) > 0 {
		UserMods.AddExistingAuthTokens(m.R.AuthTokens...).Apply(ctx, o)
	}
	if len(m.R.FailedLogins) > 0 {
		UserMods.AddExistingFailedLogins(m.R.FailedLogins...).Apply(ctx, o)
	}

	return o
}

func (f *Factory) ClearBaseAuthTokenMods() {
	f.baseAuthTokenMods = nil
}

func (f *Factory) AddBaseAuthTokenMod(mods ...AuthTokenMod) {
	f.baseAuthTokenMods = append(f.baseAuthTokenMods, mods...)
}

func (f *Factory) ClearBaseFailedLoginMods() {
	f.baseFailedLoginMods = nil
}

func (f *Factory) AddBaseFailedLoginMod(mods ...FailedLoginMod) {
	f.baseFailedLoginMods = append(f.baseFailedLoginMods, mods...)
}

func (f *Factory) ClearBaseUserMods() {
	f.baseUserMods = nil
}

func (f *Factory) AddBaseUserMod(mods ...UserMod) {
	f.baseUserMods = append(f.baseUserMods, mods...)
}
